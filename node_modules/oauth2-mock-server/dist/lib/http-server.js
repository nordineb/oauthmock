"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HttpServer_server, _HttpServer_isSecured;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpServer = void 0;
const http_1 = require("http");
const https_1 = require("https");
const net_1 = require("net");
const url_1 = require("url");
const helpers_1 = require("./helpers");
class HttpServer {
    constructor(requestListener, options) {
        _HttpServer_server.set(this, void 0);
        _HttpServer_isSecured.set(this, void 0);
        __classPrivateFieldSet(this, _HttpServer_isSecured, false, "f");
        if ((options === null || options === void 0 ? void 0 : options.key) && (options === null || options === void 0 ? void 0 : options.cert)) {
            __classPrivateFieldSet(this, _HttpServer_server, (0, https_1.createServer)(options, requestListener), "f");
            __classPrivateFieldSet(this, _HttpServer_isSecured, true, "f");
        }
        else {
            __classPrivateFieldSet(this, _HttpServer_server, (0, http_1.createServer)(requestListener), "f");
        }
    }
    get listening() {
        return __classPrivateFieldGet(this, _HttpServer_server, "f").listening;
    }
    address() {
        if (!this.listening) {
            throw new Error('Server is not started.');
        }
        const address = __classPrivateFieldGet(this, _HttpServer_server, "f").address();
        (0, helpers_1.assertIsAddressInfo)(address);
        return address;
    }
    async start(port, host) {
        if (this.listening) {
            throw new Error('Server has already been started.');
        }
        return new Promise((resolve, reject) => {
            __classPrivateFieldGet(this, _HttpServer_server, "f")
                .listen(port, host)
                .on('listening', resolve)
                .on('error', reject);
        });
    }
    async stop() {
        if (!this.listening) {
            throw new Error('Server is not started.');
        }
        return new Promise((resolve, reject) => {
            __classPrivateFieldGet(this, _HttpServer_server, "f").close((err) => {
                if (err) {
                    return reject(err);
                }
                return resolve();
            });
        });
    }
    buildIssuerUrl(host, port) {
        const url = new url_1.URL(`${__classPrivateFieldGet(this, _HttpServer_isSecured, "f") ? 'https' : 'http'}://localhost:${port}`);
        if (host && !coversLocalhost(host)) {
            url.hostname = host.includes(':') ? `[${host}]` : host;
        }
        return url.origin;
    }
}
exports.HttpServer = HttpServer;
_HttpServer_server = new WeakMap(), _HttpServer_isSecured = new WeakMap();
const coversLocalhost = (address) => {
    switch ((0, net_1.isIP)(address)) {
        case 4:
            return address === '0.0.0.0' || address.startsWith('127.');
        case 6:
            return address === '::' || address === '::1';
        default:
            return false;
    }
};
