"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OAuth2Issuer_keys;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth2Issuer = void 0;
const events_1 = require("events");
const jose_1 = require("jose");
const jwk_store_1 = require("./jwk-store");
const helpers_1 = require("./helpers");
const types_internals_1 = require("./types-internals");
class OAuth2Issuer extends events_1.EventEmitter {
    constructor() {
        super();
        _OAuth2Issuer_keys.set(this, void 0);
        this.url = undefined;
        __classPrivateFieldSet(this, _OAuth2Issuer_keys, new jwk_store_1.JWKStore(), "f");
    }
    get keys() {
        return __classPrivateFieldGet(this, _OAuth2Issuer_keys, "f");
    }
    async buildToken(opts) {
        var _a;
        const key = this.keys.get(opts === null || opts === void 0 ? void 0 : opts.kid);
        if (key === undefined) {
            throw new Error('Cannot build token: Unknown key.');
        }
        const timestamp = Math.floor(Date.now() / 1000);
        const header = {
            kid: key.kid,
        };
        (0, helpers_1.assertIsString)(this.url, 'Unknown issuer url');
        const payload = {
            iss: this.url,
            iat: timestamp,
            exp: timestamp + ((_a = opts === null || opts === void 0 ? void 0 : opts.expiresIn) !== null && _a !== void 0 ? _a : helpers_1.defaultTokenTtl),
            nbf: timestamp - 10,
        };
        if ((opts === null || opts === void 0 ? void 0 : opts.scopesOrTransform) !== undefined) {
            const scopesOrTransform = opts.scopesOrTransform;
            if (typeof scopesOrTransform === 'string') {
                payload.scope = scopesOrTransform;
            }
            else if (Array.isArray(scopesOrTransform)) {
                payload.scope = scopesOrTransform.join(' ');
            }
            else if (typeof scopesOrTransform === 'function') {
                scopesOrTransform(header, payload);
            }
        }
        const token = {
            header,
            payload,
        };
        this.emit(types_internals_1.InternalEvents.BeforeSigning, token);
        const privateKey = await (0, jose_1.importJWK)(key);
        const jwt = await new jose_1.SignJWT(token.payload)
            .setProtectedHeader({ ...token.header, typ: 'JWT', alg: key.alg })
            .sign(privateKey);
        return jwt;
    }
}
exports.OAuth2Issuer = OAuth2Issuer;
_OAuth2Issuer_keys = new WeakMap();
