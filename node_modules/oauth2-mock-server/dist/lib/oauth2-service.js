"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _OAuth2Service_issuer, _OAuth2Service_requestHandler, _OAuth2Service_nonce, _OAuth2Service_endpoints;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth2Service = void 0;
const url_1 = require("url");
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const basic_auth_1 = __importDefault(require("basic-auth"));
const events_1 = require("events");
const uuid_1 = require("uuid");
const body_parser_1 = require("body-parser");
const helpers_1 = require("./helpers");
const types_1 = require("./types");
const types_internals_1 = require("./types-internals");
const DEFAULT_ENDPOINTS = Object.freeze({
    wellKnownDocument: '/.well-known/openid-configuration',
    token: '/token',
    jwks: '/jwks',
    authorize: '/authorize',
    userinfo: '/userinfo',
    revoke: '/revoke',
    endSession: '/endsession',
    introspect: '/introspect',
});
class OAuth2Service extends events_1.EventEmitter {
    constructor(oauth2Issuer, endpoints) {
        super();
        _OAuth2Service_issuer.set(this, void 0);
        _OAuth2Service_requestHandler.set(this, void 0);
        _OAuth2Service_nonce.set(this, void 0);
        _OAuth2Service_endpoints.set(this, void 0);
        this.buildRequestHandler = () => {
            const app = (0, express_1.default)();
            app.disable('x-powered-by');
            app.use((0, body_parser_1.json)());
            app.use((0, cors_1.default)());
            app.get(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").wellKnownDocument, this.openidConfigurationHandler);
            app.get(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").jwks, this.jwksHandler);
            app.post(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").token, express_1.default.urlencoded({ extended: false }), this.tokenHandler);
            app.get(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").authorize, this.authorizeHandler);
            app.get(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").userinfo, this.userInfoHandler);
            app.post(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").revoke, this.revokeHandler);
            app.get(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").endSession, this.endSessionHandler);
            app.post(__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").introspect, this.introspectHandler);
            return app;
        };
        this.openidConfigurationHandler = (_req, res) => {
            (0, helpers_1.assertIsString)(this.issuer.url, 'Unknown issuer url.');
            const openidConfig = {
                issuer: this.issuer.url,
                token_endpoint: `${this.issuer.url}${__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").token}`,
                authorization_endpoint: `${this.issuer.url}${__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").authorize}`,
                userinfo_endpoint: `${this.issuer.url}${__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").userinfo}`,
                token_endpoint_auth_methods_supported: ['none'],
                jwks_uri: `${this.issuer.url}${__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").jwks}`,
                response_types_supported: ['code'],
                grant_types_supported: [
                    'client_credentials',
                    'authorization_code',
                    'password',
                ],
                token_endpoint_auth_signing_alg_values_supported: ['RS256'],
                response_modes_supported: ['query'],
                id_token_signing_alg_values_supported: ['RS256'],
                revocation_endpoint: `${this.issuer.url}${__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").revoke}`,
                subject_types_supported: ['public'],
                end_session_endpoint: `${this.issuer.url}${__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").endSession}`,
                introspection_endpoint: `${this.issuer.url}${__classPrivateFieldGet(this, _OAuth2Service_endpoints, "f").introspect}`,
            };
            return res.json(openidConfig);
        };
        this.jwksHandler = (_req, res) => {
            res.json({ keys: this.issuer.keys.toJSON() });
        };
        this.tokenHandler = async (req, res, next) => {
            try {
                const tokenTtl = helpers_1.defaultTokenTtl;
                res.set({
                    'Cache-Control': 'no-store',
                    Pragma: 'no-cache',
                });
                let xfn;
                (0, helpers_1.assertIsValidTokenRequest)(req.body);
                const reqBody = req.body;
                let { scope } = reqBody;
                switch (req.body.grant_type) {
                    case 'client_credentials':
                        xfn = scope;
                        break;
                    case 'password':
                        xfn = (_header, payload) => {
                            Object.assign(payload, {
                                sub: reqBody.username,
                                amr: ['pwd'],
                                scope,
                            });
                        };
                        break;
                    case 'authorization_code':
                        scope = 'dummy';
                        xfn = (_header, payload) => {
                            Object.assign(payload, {
                                sub: 'johndoe',
                                amr: ['pwd'],
                                scope,
                            });
                        };
                        break;
                    case 'refresh_token':
                        scope = 'dummy';
                        xfn = (_header, payload) => {
                            Object.assign(payload, {
                                sub: 'johndoe',
                                amr: ['pwd'],
                                scope,
                            });
                        };
                        break;
                    default:
                        return res.status(400).json({
                            error: 'invalid_grant',
                        });
                }
                const token = await this.buildToken(req, tokenTtl, xfn);
                const body = {
                    access_token: token,
                    token_type: 'Bearer',
                    expires_in: tokenTtl,
                    scope,
                };
                if (req.body.grant_type !== 'client_credentials') {
                    const credentials = (0, basic_auth_1.default)(req);
                    const clientId = credentials ? credentials.name : req.body.client_id;
                    const xfn = (_header, payload) => {
                        Object.assign(payload, {
                            sub: 'johndoe',
                            aud: clientId,
                        });
                        if (reqBody.code !== undefined && __classPrivateFieldGet(this, _OAuth2Service_nonce, "f")[reqBody.code]) {
                            Object.assign(payload, {
                                nonce: __classPrivateFieldGet(this, _OAuth2Service_nonce, "f")[reqBody.code],
                            });
                            delete __classPrivateFieldGet(this, _OAuth2Service_nonce, "f")[reqBody.code];
                        }
                    };
                    body.id_token = await this.buildToken(req, tokenTtl, xfn);
                    body.refresh_token = (0, uuid_1.v4)();
                }
                const tokenEndpointResponse = {
                    body,
                    statusCode: 200,
                };
                this.emit(types_1.Events.BeforeResponse, tokenEndpointResponse, req);
                return res
                    .status(tokenEndpointResponse.statusCode)
                    .json(tokenEndpointResponse.body);
            }
            catch (e) {
                return next(e);
            }
        };
        this.authorizeHandler = (req, res) => {
            const { scope, state } = req.query;
            const responseType = req.query.response_type;
            const redirectUri = req.query.redirect_uri;
            const code = (0, uuid_1.v4)();
            let queryNonce;
            if ('nonce' in req.query) {
                (0, helpers_1.assertIsString)(req.query.nonce, 'Invalid nonce type');
                queryNonce = req.query.nonce;
            }
            (0, helpers_1.assertIsString)(redirectUri, 'Invalid redirectUri type');
            (0, helpers_1.assertIsString)(scope, 'Invalid scope type');
            (0, helpers_1.assertIsString)(state, 'Invalid state type');
            const url = new url_1.URL(redirectUri);
            if (responseType === 'code') {
                if (queryNonce !== undefined) {
                    __classPrivateFieldGet(this, _OAuth2Service_nonce, "f")[code] = queryNonce;
                }
                url.searchParams.set('code', code);
                url.searchParams.set('scope', scope);
                url.searchParams.set('state', state);
            }
            else {
                url.searchParams.set('error', 'unsupported_response_type');
                url.searchParams.set('error_description', 'The authorization server does not support obtaining an access token using this response_type.');
                url.searchParams.set('state', state);
            }
            const authorizeRedirectUri = { url };
            this.emit(types_1.Events.BeforeAuthorizeRedirect, authorizeRedirectUri, req);
            res.redirect(url.href);
        };
        this.userInfoHandler = (req, res) => {
            const userInfoResponse = {
                body: {
                    sub: 'johndoe',
                },
                statusCode: 200,
            };
            this.emit(types_1.Events.BeforeUserinfo, userInfoResponse, req);
            res.status(userInfoResponse.statusCode).json(userInfoResponse.body);
        };
        this.revokeHandler = (req, res) => {
            const revokeResponse = {
                statusCode: 200,
            };
            this.emit(types_1.Events.BeforeRevoke, revokeResponse, req);
            return res.status(revokeResponse.statusCode).send('');
        };
        this.endSessionHandler = (req, res) => {
            (0, helpers_1.assertIsString)(req.query.post_logout_redirect_uri, 'Invalid post_logout_redirect_uri type');
            const postLogoutRedirectUri = {
                url: new url_1.URL(req.query.post_logout_redirect_uri),
            };
            this.emit(types_1.Events.BeforePostLogoutRedirect, postLogoutRedirectUri, req);
            res.redirect(postLogoutRedirectUri.url.href);
        };
        this.introspectHandler = (req, res) => {
            const introspectResponse = {
                body: {
                    active: true,
                },
                statusCode: 200,
            };
            this.emit(types_1.Events.BeforeIntrospect, introspectResponse, req);
            res.status(introspectResponse.statusCode).json(introspectResponse.body);
        };
        __classPrivateFieldSet(this, _OAuth2Service_issuer, oauth2Issuer, "f");
        __classPrivateFieldSet(this, _OAuth2Service_endpoints, { ...DEFAULT_ENDPOINTS, ...endpoints }, "f");
        __classPrivateFieldSet(this, _OAuth2Service_requestHandler, this.buildRequestHandler(), "f");
        __classPrivateFieldSet(this, _OAuth2Service_nonce, {}, "f");
    }
    get issuer() {
        return __classPrivateFieldGet(this, _OAuth2Service_issuer, "f");
    }
    async buildToken(req, expiresIn, scopesOrTransform) {
        this.issuer.once(types_internals_1.InternalEvents.BeforeSigning, (token) => {
            this.emit(types_1.Events.BeforeTokenSigning, token, req);
        });
        return await this.issuer.buildToken({ scopesOrTransform, expiresIn });
    }
    get requestHandler() {
        return __classPrivateFieldGet(this, _OAuth2Service_requestHandler, "f");
    }
}
exports.OAuth2Service = OAuth2Service;
_OAuth2Service_issuer = new WeakMap(), _OAuth2Service_requestHandler = new WeakMap(), _OAuth2Service_nonce = new WeakMap(), _OAuth2Service_endpoints = new WeakMap();
