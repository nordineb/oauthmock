"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _JWKStore_keyRotator, _KeyRotator_keys;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWKStore = void 0;
const crypto_1 = require("crypto");
const jose_1 = require("jose");
const generateRandomKid = () => {
    return (0, crypto_1.randomBytes)(40).toString('hex');
};
const RsaPrivateFieldsRemover = (jwk) => {
    const x = { ...jwk };
    delete x.d;
    delete x.p;
    delete x.q;
    delete x.dp;
    delete x.dq;
    delete x.qi;
    return x;
};
const EcdsaPrivateFieldsRemover = (jwk) => {
    const x = { ...jwk };
    delete x.d;
    return x;
};
const EddsaPrivateFieldsRemover = (jwk) => {
    const x = { ...jwk };
    delete x.d;
    return x;
};
const privateToPublicTransformerMap = {
    RS256: RsaPrivateFieldsRemover,
    RS384: RsaPrivateFieldsRemover,
    RS512: RsaPrivateFieldsRemover,
    PS256: RsaPrivateFieldsRemover,
    PS384: RsaPrivateFieldsRemover,
    PS512: RsaPrivateFieldsRemover,
    ES256: EcdsaPrivateFieldsRemover,
    ES256K: EcdsaPrivateFieldsRemover,
    ES384: EcdsaPrivateFieldsRemover,
    ES512: EcdsaPrivateFieldsRemover,
    EdDSA: EddsaPrivateFieldsRemover,
};
const supportedAlgs = Object.keys(privateToPublicTransformerMap);
function normalizeKeyKid(jwk, opts) {
    if (jwk.kid !== undefined) {
        return;
    }
    if (opts !== undefined && opts.kid !== undefined) {
        jwk.kid = opts.kid;
    }
    else {
        jwk.kid = generateRandomKid();
    }
}
class JWKStore {
    constructor() {
        _JWKStore_keyRotator.set(this, void 0);
        __classPrivateFieldSet(this, _JWKStore_keyRotator, new KeyRotator(), "f");
    }
    async generate(alg, opts) {
        const generateOpts = opts !== undefined && opts.crv !== undefined ? { crv: opts.crv } : {};
        const pair = await (0, jose_1.generateKeyPair)(alg, generateOpts);
        const joseJwk = await (0, jose_1.exportJWK)(pair.privateKey);
        normalizeKeyKid(joseJwk, opts);
        joseJwk.alg = alg;
        const jwk = joseJwk;
        __classPrivateFieldGet(this, _JWKStore_keyRotator, "f").add(jwk);
        return jwk;
    }
    async add(maybeJwk) {
        const tempJwk = { ...maybeJwk };
        normalizeKeyKid(tempJwk);
        if (tempJwk.alg === undefined) {
            throw new Error('Unspecified JWK "alg" property');
        }
        if (!supportedAlgs.includes(tempJwk.alg)) {
            throw new Error(`Unsupported JWK "alg" value ("${tempJwk.alg}")`);
        }
        const jwk = tempJwk;
        const privateKey = await (0, jose_1.importJWK)(jwk);
        if (!(privateKey instanceof crypto_1.KeyObject) || privateKey.type !== 'private') {
            throw new Error(`Invalid JWK type. No "private" key related data has been found.`);
        }
        __classPrivateFieldGet(this, _JWKStore_keyRotator, "f").add(jwk);
        return jwk;
    }
    get(kid) {
        return __classPrivateFieldGet(this, _JWKStore_keyRotator, "f").next(kid);
    }
    toJSON(includePrivateFields = false) {
        return __classPrivateFieldGet(this, _JWKStore_keyRotator, "f").toJSON(includePrivateFields);
    }
}
exports.JWKStore = JWKStore;
_JWKStore_keyRotator = new WeakMap();
class KeyRotator {
    constructor() {
        _KeyRotator_keys.set(this, []);
    }
    add(key) {
        const pos = this.findNext(key.kid);
        if (pos > -1) {
            __classPrivateFieldGet(this, _KeyRotator_keys, "f").splice(pos, 1);
        }
        __classPrivateFieldGet(this, _KeyRotator_keys, "f").push(key);
    }
    next(kid) {
        const i = this.findNext(kid);
        if (i === -1) {
            return undefined;
        }
        return this.moveToTheEnd(i);
    }
    toJSON(includePrivateFields) {
        const keys = [];
        for (const key of __classPrivateFieldGet(this, _KeyRotator_keys, "f")) {
            if (includePrivateFields) {
                keys.push({ ...key });
                continue;
            }
            const cleaner = privateToPublicTransformerMap[key.alg];
            keys.push(cleaner(key));
        }
        return keys;
    }
    findNext(kid) {
        if (__classPrivateFieldGet(this, _KeyRotator_keys, "f").length === 0) {
            return -1;
        }
        if (kid === undefined) {
            return 0;
        }
        return __classPrivateFieldGet(this, _KeyRotator_keys, "f").findIndex((x) => x.kid === kid);
    }
    moveToTheEnd(i) {
        const [key] = __classPrivateFieldGet(this, _KeyRotator_keys, "f").splice(i, 1);
        __classPrivateFieldGet(this, _KeyRotator_keys, "f").push(key);
        return key;
    }
}
_KeyRotator_keys = new WeakMap();
